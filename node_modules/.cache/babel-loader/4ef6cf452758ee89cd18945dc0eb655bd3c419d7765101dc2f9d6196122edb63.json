{"ast":null,"code":"/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n'use strict';\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { subscribe } from 'subscribe-ui-event';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\n\n// constants\nconst STATUS_ORIGINAL = 0; // The default status, locating at the original position.\nconst STATUS_RELEASED = 1; // The released status, locating at somewhere on document but not default one.\nconst STATUS_FIXED = 2; // The sticky status, locating fixed to the top or the bottom of screen.\n\nlet TRANSFORM_PROP = 'transform';\n\n// global variable for all instances\nlet doc;\nlet docBody;\nlet docEl;\nlet canEnableTransforms = true; // Use transform by default, so no Sticky on lower-end browser when no Modernizr\nlet M;\nlet scrollDelta = 0;\nlet win;\nlet winHeight = -1;\nclass Sticky extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.handleResize = this.handleResize.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n    this.handleScrollStart = this.handleScrollStart.bind(this);\n    this.delta = 0;\n    this.stickyTop = 0;\n    this.stickyBottom = 0;\n    this.frozen = false;\n    this.skipNextScrollEvent = false;\n    this.scrollTop = -1;\n    this.bottomBoundaryTarget;\n    this.topTarget;\n    this.subscribers;\n    this.state = {\n      top: 0,\n      // A top offset from viewport top where Sticky sticks to when scrolling up\n      bottom: 0,\n      // A bottom offset from viewport top where Sticky sticks to when scrolling down\n      width: 0,\n      // Sticky width\n      height: 0,\n      // Sticky height\n      x: 0,\n      // The original x of Sticky\n      y: 0,\n      // The original y of Sticky\n      topBoundary: 0,\n      // The top boundary on document\n      bottomBoundary: Infinity,\n      // The bottom boundary on document\n      status: STATUS_ORIGINAL,\n      // The Sticky status\n      pos: 0,\n      // Real y-axis offset for rendering position-fixed and position-relative\n      activated: false // once browser info is available after mounted, it becomes true to avoid checksum error\n    };\n  }\n  getTargetHeight(target) {\n    return target && target.offsetHeight || 0;\n  }\n  getTopPosition(top) {\n    // a top argument can be provided to override reading from the props\n    top = top || this.props.top || 0;\n    if (typeof top === 'string') {\n      if (!this.topTarget) {\n        this.topTarget = doc.querySelector(top);\n      }\n      top = this.getTargetHeight(this.topTarget);\n    }\n    return top;\n  }\n  getTargetBottom(target) {\n    if (!target) {\n      return -1;\n    }\n    const rect = target.getBoundingClientRect();\n    return this.scrollTop + rect.bottom;\n  }\n  getBottomBoundary(bottomBoundary) {\n    // a bottomBoundary can be provided to avoid reading from the props\n    let boundary = bottomBoundary || this.props.bottomBoundary;\n\n    // TODO, bottomBoundary was an object, depricate it later.\n    if (typeof boundary === 'object') {\n      boundary = boundary.value || boundary.target || 0;\n    }\n    if (typeof boundary === 'string') {\n      if (!this.bottomBoundaryTarget) {\n        this.bottomBoundaryTarget = doc.querySelector(boundary);\n      }\n      boundary = this.getTargetBottom(this.bottomBoundaryTarget);\n    }\n    return boundary && boundary > 0 ? boundary : Infinity;\n  }\n  reset() {\n    this.setState({\n      status: STATUS_ORIGINAL,\n      pos: 0\n    });\n  }\n  release(pos) {\n    this.setState({\n      status: STATUS_RELEASED,\n      pos: pos - this.state.y\n    });\n  }\n  fix(pos) {\n    this.setState({\n      status: STATUS_FIXED,\n      pos: pos\n    });\n  }\n\n  /**\n   * Update the initial position, width, and height. It should update whenever children change.\n   * @param {Object} options optional top and bottomBoundary new values\n   */\n  updateInitialDimension(options) {\n    options = options || {};\n    if (!this.outerElement || !this.innerElement) {\n      return;\n    }\n    const outerRect = this.outerElement.getBoundingClientRect();\n    const innerRect = this.innerElement.getBoundingClientRect();\n    const width = outerRect.width || outerRect.right - outerRect.left;\n    const height = innerRect.height || innerRect.bottom - innerRect.top;\n    const outerY = outerRect.top + this.scrollTop;\n    this.setState({\n      top: this.getTopPosition(options.top),\n      bottom: Math.min(this.state.top + height, winHeight),\n      width,\n      height,\n      x: outerRect.left,\n      y: outerY,\n      bottomBoundary: this.getBottomBoundary(options.bottomBoundary),\n      topBoundary: outerY\n    });\n  }\n  handleResize(e, ae) {\n    if (this.props.shouldFreeze()) {\n      return;\n    }\n    winHeight = ae.resize.height;\n    this.updateInitialDimension();\n    this.update();\n  }\n  handleScrollStart(e, ae) {\n    this.frozen = this.props.shouldFreeze();\n    if (this.frozen) {\n      return;\n    }\n    if (this.scrollTop === ae.scroll.top) {\n      // Scroll position hasn't changed,\n      // do nothing\n      this.skipNextScrollEvent = true;\n    } else {\n      this.scrollTop = ae.scroll.top;\n      this.updateInitialDimension();\n    }\n  }\n  handleScroll(e, ae) {\n    // Scroll doesn't need to be handled\n    if (this.skipNextScrollEvent) {\n      this.skipNextScrollEvent = false;\n      return;\n    }\n    scrollDelta = ae.scroll.delta;\n    this.scrollTop = ae.scroll.top;\n    this.update();\n  }\n\n  /**\n   * Update Sticky position.\n   */\n  update() {\n    var disabled = !this.props.enabled || this.state.bottomBoundary - this.state.topBoundary <= this.state.height || this.state.width === 0 && this.state.height === 0;\n    if (disabled) {\n      if (this.state.status !== STATUS_ORIGINAL) {\n        this.reset();\n      }\n      return;\n    }\n    var delta = scrollDelta;\n    // \"top\" and \"bottom\" are the positions that this.state.top and this.state.bottom project\n    // on document from viewport.\n    var top = this.scrollTop + this.state.top;\n    var bottom = this.scrollTop + this.state.bottom;\n\n    // There are 2 principles to make sure Sticky won't get wrong so much:\n    // 1. Reset Sticky to the original postion when \"top\" <= topBoundary\n    // 2. Release Sticky to the bottom boundary when \"bottom\" >= bottomBoundary\n    if (top <= this.state.topBoundary) {\n      // #1\n      this.reset();\n    } else if (bottom >= this.state.bottomBoundary) {\n      // #2\n      this.stickyBottom = this.state.bottomBoundary;\n      this.stickyTop = this.stickyBottom - this.state.height;\n      this.release(this.stickyTop);\n    } else {\n      if (this.state.height > winHeight - this.state.top) {\n        // In this case, Sticky is higher then viewport minus top offset\n        switch (this.state.status) {\n          case STATUS_ORIGINAL:\n            this.release(this.state.y);\n            this.stickyTop = this.state.y;\n            this.stickyBottom = this.stickyTop + this.state.height;\n          // Commentting out \"break\" is on purpose, because there is a chance to transit to FIXED\n          // from ORIGINAL when calling window.scrollTo().\n          // break;\n          /* eslint-disable-next-line no-fallthrough */\n          case STATUS_RELEASED:\n            // If \"top\" and \"bottom\" are inbetween stickyTop and stickyBottom, then Sticky is in\n            // RELEASE status. Otherwise, it changes to FIXED status, and its bottom sticks to\n            // viewport bottom when scrolling down, or its top sticks to viewport top when scrolling up.\n            this.stickyBottom = this.stickyTop + this.state.height;\n            if (delta > 0 && bottom > this.stickyBottom) {\n              this.fix(this.state.bottom - this.state.height);\n            } else if (delta < 0 && top < this.stickyTop) {\n              this.fix(this.state.top);\n            }\n            break;\n          case STATUS_FIXED:\n            var toRelease = true;\n            var pos = this.state.pos;\n            var height = this.state.height;\n            // In regular cases, when Sticky is in FIXED status,\n            // 1. it's top will stick to the screen top,\n            // 2. it's bottom will stick to the screen bottom,\n            // 3. if not the cases above, then it's height gets changed\n            if (delta > 0 && pos === this.state.top) {\n              // case 1, and scrolling down\n              this.stickyTop = top - delta;\n              this.stickyBottom = this.stickyTop + height;\n            } else if (delta < 0 && pos === this.state.bottom - height) {\n              // case 2, and scrolling up\n              this.stickyBottom = bottom - delta;\n              this.stickyTop = this.stickyBottom - height;\n            } else if (pos !== this.state.bottom - height && pos !== this.state.top) {\n              // case 3\n              // This case only happens when Sticky's bottom sticks to the screen bottom and\n              // its height gets changed. Sticky should be in RELEASE status and update its\n              // sticky bottom by calculating how much height it changed.\n              const deltaHeight = pos + height - this.state.bottom;\n              this.stickyBottom = bottom - delta + deltaHeight;\n              this.stickyTop = this.stickyBottom - height;\n            } else {\n              toRelease = false;\n            }\n            if (toRelease) {\n              this.release(this.stickyTop);\n            }\n            break;\n        }\n      } else {\n        // In this case, Sticky is shorter then viewport minus top offset\n        // and will always fix to the top offset of viewport\n        this.fix(this.state.top);\n      }\n    }\n    this.delta = delta;\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.status !== this.state.status && this.props.onStateChange) {\n      this.props.onStateChange({\n        status: this.state.status\n      });\n    }\n\n    // check if we are up-to-date, is triggered in case of scroll restoration\n    if (this.state.top !== prevState.top) {\n      this.updateInitialDimension();\n      this.update();\n    }\n    const arePropsChanged = !shallowEqual(this.props, prevProps);\n    if (arePropsChanged) {\n      // if the props for enabling are toggled, then trigger the update or reset depending on the current props\n      if (prevProps.enabled !== this.props.enabled) {\n        if (this.props.enabled) {\n          this.setState({\n            activated: true\n          }, () => {\n            this.updateInitialDimension();\n            this.update();\n          });\n        } else {\n          this.setState({\n            activated: false\n          }, () => {\n            this.reset();\n          });\n        }\n      }\n      // if the top or bottomBoundary props were changed, then trigger the update\n      else if (prevProps.top !== this.props.top || prevProps.bottomBoundary !== this.props.bottomBoundary) {\n        this.updateInitialDimension();\n        this.update();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const subscribers = this.subscribers || [];\n    for (var i = subscribers.length - 1; i >= 0; i--) {\n      this.subscribers[i].unsubscribe();\n    }\n  }\n  componentDidMount() {\n    // Only initialize the globals if this is the first\n    // time this component type has been mounted\n    if (!win) {\n      win = window;\n      doc = document;\n      docEl = doc.documentElement;\n      docBody = doc.body;\n      winHeight = win.innerHeight || docEl.clientHeight;\n      M = window.Modernizr;\n      // No Sticky on lower-end browser when no Modernizr\n      if (M && M.prefixed) {\n        canEnableTransforms = M.csstransforms3d;\n        TRANSFORM_PROP = M.prefixed('transform');\n      }\n    }\n\n    // when mount, the scrollTop is not necessary on the top\n    this.scrollTop = docBody.scrollTop + docEl.scrollTop;\n    if (this.props.enabled) {\n      this.setState({\n        activated: true\n      });\n      this.updateInitialDimension();\n      this.update();\n    }\n    // bind the listeners regardless if initially enabled - allows the component to toggle sticky functionality\n    this.subscribers = [subscribe('scrollStart', this.handleScrollStart.bind(this), {\n      useRAF: true\n    }), subscribe('scroll', this.handleScroll.bind(this), {\n      useRAF: true,\n      enableScrollInfo: true\n    }), subscribe('resize', this.handleResize.bind(this), {\n      enableResizeInfo: true\n    })];\n  }\n  translate(style, pos) {\n    const enableTransforms = canEnableTransforms && this.props.enableTransforms;\n    if (enableTransforms && this.state.activated) {\n      style[TRANSFORM_PROP] = 'translate3d(0,' + Math.round(pos) + 'px,0)';\n    } else {\n      style.top = pos + 'px';\n    }\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    return !this.props.shouldFreeze() && !(shallowEqual(this.props, nextProps) && shallowEqual(this.state, nextState));\n  }\n  render() {\n    // TODO, \"overflow: auto\" prevents collapse, need a good way to get children height\n    const innerStyle = {\n      position: this.state.status === STATUS_FIXED ? 'fixed' : 'relative',\n      top: this.state.status === STATUS_FIXED ? '0px' : '',\n      zIndex: this.props.innerZ\n    };\n    const outerStyle = {};\n\n    // always use translate3d to enhance the performance\n    this.translate(innerStyle, this.state.pos);\n    if (this.state.status !== STATUS_ORIGINAL) {\n      innerStyle.width = this.state.width + 'px';\n      outerStyle.height = this.state.height + 'px';\n    }\n    const outerClasses = classNames('sticky-outer-wrapper', this.props.className, {\n      [this.props.activeClass]: this.state.status === STATUS_FIXED,\n      [this.props.releasedClass]: this.state.status === STATUS_RELEASED\n    });\n    const innerClasses = classNames('sticky-inner-wrapper', this.props.innerClass, {\n      [this.props.innerActiveClass]: this.state.status === STATUS_FIXED\n    });\n    const children = this.props.children;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: outer => {\n        this.outerElement = outer;\n      },\n      className: outerClasses,\n      style: outerStyle\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      ref: inner => {\n        this.innerElement = inner;\n      },\n      className: innerClasses,\n      style: innerStyle\n    }, typeof children === 'function' ? children({\n      status: this.state.status\n    }) : children));\n  }\n}\nSticky.displayName = 'Sticky';\nSticky.defaultProps = {\n  shouldFreeze: function () {\n    return false;\n  },\n  enabled: true,\n  top: 0,\n  bottomBoundary: 0,\n  enableTransforms: true,\n  activeClass: 'active',\n  releasedClass: 'released',\n  onStateChange: null,\n  innerClass: '',\n  innerActiveClass: ''\n};\n\n/**\n * @param {Bool} enabled A switch to enable or disable Sticky.\n * @param {String/Number} top A top offset px for Sticky. Could be a selector representing a node\n *        whose height should serve as the top offset.\n * @param {String/Number} bottomBoundary A bottom boundary px on document where Sticky will stop.\n *        Could be a selector representing a node whose bottom should serve as the bottom boudary.\n */\nSticky.propTypes = {\n  children: PropTypes.elementType,\n  enabled: PropTypes.bool,\n  top: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  bottomBoundary: PropTypes.oneOfType([PropTypes.object,\n  // TODO, may remove\n  PropTypes.string, PropTypes.number]),\n  enableTransforms: PropTypes.bool,\n  activeClass: PropTypes.string,\n  releasedClass: PropTypes.string,\n  innerClass: PropTypes.string,\n  innerActiveClass: PropTypes.string,\n  className: PropTypes.string,\n  onStateChange: PropTypes.func,\n  shouldFreeze: PropTypes.func,\n  innerZ: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\nSticky.STATUS_ORIGINAL = STATUS_ORIGINAL;\nSticky.STATUS_RELEASED = STATUS_RELEASED;\nSticky.STATUS_FIXED = STATUS_FIXED;\nexport default Sticky;","map":{"version":3,"names":["React","Component","PropTypes","subscribe","classNames","shallowEqual","STATUS_ORIGINAL","STATUS_RELEASED","STATUS_FIXED","TRANSFORM_PROP","doc","docBody","docEl","canEnableTransforms","M","scrollDelta","win","winHeight","Sticky","constructor","props","context","handleResize","bind","handleScroll","handleScrollStart","delta","stickyTop","stickyBottom","frozen","skipNextScrollEvent","scrollTop","bottomBoundaryTarget","topTarget","subscribers","state","top","bottom","width","height","x","y","topBoundary","bottomBoundary","Infinity","status","pos","activated","getTargetHeight","target","offsetHeight","getTopPosition","querySelector","getTargetBottom","rect","getBoundingClientRect","getBottomBoundary","boundary","value","reset","setState","release","fix","updateInitialDimension","options","outerElement","innerElement","outerRect","innerRect","right","left","outerY","Math","min","e","ae","shouldFreeze","resize","update","scroll","disabled","enabled","toRelease","deltaHeight","componentDidUpdate","prevProps","prevState","onStateChange","arePropsChanged","componentWillUnmount","i","length","unsubscribe","componentDidMount","window","document","documentElement","body","innerHeight","clientHeight","Modernizr","prefixed","csstransforms3d","useRAF","enableScrollInfo","enableResizeInfo","translate","style","enableTransforms","round","shouldComponentUpdate","nextProps","nextState","render","innerStyle","position","zIndex","innerZ","outerStyle","outerClasses","className","activeClass","releasedClass","innerClasses","innerClass","innerActiveClass","children","createElement","ref","outer","inner","displayName","defaultProps","propTypes","elementType","bool","oneOfType","string","number","object","func"],"sources":["C:/xampp/htdocs/fm_react_mysql/node_modules/react-stickynode/dist/es/Sticky.js"],"sourcesContent":["/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n'use strict';\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { subscribe } from 'subscribe-ui-event';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\n\n// constants\nconst STATUS_ORIGINAL = 0; // The default status, locating at the original position.\nconst STATUS_RELEASED = 1; // The released status, locating at somewhere on document but not default one.\nconst STATUS_FIXED = 2; // The sticky status, locating fixed to the top or the bottom of screen.\n\nlet TRANSFORM_PROP = 'transform';\n\n// global variable for all instances\nlet doc;\nlet docBody;\nlet docEl;\nlet canEnableTransforms = true; // Use transform by default, so no Sticky on lower-end browser when no Modernizr\nlet M;\nlet scrollDelta = 0;\nlet win;\nlet winHeight = -1;\nclass Sticky extends Component {\n  constructor(props, context) {\n    super(props, context);\n    this.handleResize = this.handleResize.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n    this.handleScrollStart = this.handleScrollStart.bind(this);\n    this.delta = 0;\n    this.stickyTop = 0;\n    this.stickyBottom = 0;\n    this.frozen = false;\n    this.skipNextScrollEvent = false;\n    this.scrollTop = -1;\n    this.bottomBoundaryTarget;\n    this.topTarget;\n    this.subscribers;\n    this.state = {\n      top: 0,\n      // A top offset from viewport top where Sticky sticks to when scrolling up\n      bottom: 0,\n      // A bottom offset from viewport top where Sticky sticks to when scrolling down\n      width: 0,\n      // Sticky width\n      height: 0,\n      // Sticky height\n      x: 0,\n      // The original x of Sticky\n      y: 0,\n      // The original y of Sticky\n      topBoundary: 0,\n      // The top boundary on document\n      bottomBoundary: Infinity,\n      // The bottom boundary on document\n      status: STATUS_ORIGINAL,\n      // The Sticky status\n      pos: 0,\n      // Real y-axis offset for rendering position-fixed and position-relative\n      activated: false // once browser info is available after mounted, it becomes true to avoid checksum error\n    };\n  }\n  getTargetHeight(target) {\n    return target && target.offsetHeight || 0;\n  }\n  getTopPosition(top) {\n    // a top argument can be provided to override reading from the props\n    top = top || this.props.top || 0;\n    if (typeof top === 'string') {\n      if (!this.topTarget) {\n        this.topTarget = doc.querySelector(top);\n      }\n      top = this.getTargetHeight(this.topTarget);\n    }\n    return top;\n  }\n  getTargetBottom(target) {\n    if (!target) {\n      return -1;\n    }\n    const rect = target.getBoundingClientRect();\n    return this.scrollTop + rect.bottom;\n  }\n  getBottomBoundary(bottomBoundary) {\n    // a bottomBoundary can be provided to avoid reading from the props\n    let boundary = bottomBoundary || this.props.bottomBoundary;\n\n    // TODO, bottomBoundary was an object, depricate it later.\n    if (typeof boundary === 'object') {\n      boundary = boundary.value || boundary.target || 0;\n    }\n    if (typeof boundary === 'string') {\n      if (!this.bottomBoundaryTarget) {\n        this.bottomBoundaryTarget = doc.querySelector(boundary);\n      }\n      boundary = this.getTargetBottom(this.bottomBoundaryTarget);\n    }\n    return boundary && boundary > 0 ? boundary : Infinity;\n  }\n  reset() {\n    this.setState({\n      status: STATUS_ORIGINAL,\n      pos: 0\n    });\n  }\n  release(pos) {\n    this.setState({\n      status: STATUS_RELEASED,\n      pos: pos - this.state.y\n    });\n  }\n  fix(pos) {\n    this.setState({\n      status: STATUS_FIXED,\n      pos: pos\n    });\n  }\n\n  /**\n   * Update the initial position, width, and height. It should update whenever children change.\n   * @param {Object} options optional top and bottomBoundary new values\n   */\n  updateInitialDimension(options) {\n    options = options || {};\n    if (!this.outerElement || !this.innerElement) {\n      return;\n    }\n    const outerRect = this.outerElement.getBoundingClientRect();\n    const innerRect = this.innerElement.getBoundingClientRect();\n    const width = outerRect.width || outerRect.right - outerRect.left;\n    const height = innerRect.height || innerRect.bottom - innerRect.top;\n    const outerY = outerRect.top + this.scrollTop;\n    this.setState({\n      top: this.getTopPosition(options.top),\n      bottom: Math.min(this.state.top + height, winHeight),\n      width,\n      height,\n      x: outerRect.left,\n      y: outerY,\n      bottomBoundary: this.getBottomBoundary(options.bottomBoundary),\n      topBoundary: outerY\n    });\n  }\n  handleResize(e, ae) {\n    if (this.props.shouldFreeze()) {\n      return;\n    }\n    winHeight = ae.resize.height;\n    this.updateInitialDimension();\n    this.update();\n  }\n  handleScrollStart(e, ae) {\n    this.frozen = this.props.shouldFreeze();\n    if (this.frozen) {\n      return;\n    }\n    if (this.scrollTop === ae.scroll.top) {\n      // Scroll position hasn't changed,\n      // do nothing\n      this.skipNextScrollEvent = true;\n    } else {\n      this.scrollTop = ae.scroll.top;\n      this.updateInitialDimension();\n    }\n  }\n  handleScroll(e, ae) {\n    // Scroll doesn't need to be handled\n    if (this.skipNextScrollEvent) {\n      this.skipNextScrollEvent = false;\n      return;\n    }\n    scrollDelta = ae.scroll.delta;\n    this.scrollTop = ae.scroll.top;\n    this.update();\n  }\n\n  /**\n   * Update Sticky position.\n   */\n  update() {\n    var disabled = !this.props.enabled || this.state.bottomBoundary - this.state.topBoundary <= this.state.height || this.state.width === 0 && this.state.height === 0;\n    if (disabled) {\n      if (this.state.status !== STATUS_ORIGINAL) {\n        this.reset();\n      }\n      return;\n    }\n    var delta = scrollDelta;\n    // \"top\" and \"bottom\" are the positions that this.state.top and this.state.bottom project\n    // on document from viewport.\n    var top = this.scrollTop + this.state.top;\n    var bottom = this.scrollTop + this.state.bottom;\n\n    // There are 2 principles to make sure Sticky won't get wrong so much:\n    // 1. Reset Sticky to the original postion when \"top\" <= topBoundary\n    // 2. Release Sticky to the bottom boundary when \"bottom\" >= bottomBoundary\n    if (top <= this.state.topBoundary) {\n      // #1\n      this.reset();\n    } else if (bottom >= this.state.bottomBoundary) {\n      // #2\n      this.stickyBottom = this.state.bottomBoundary;\n      this.stickyTop = this.stickyBottom - this.state.height;\n      this.release(this.stickyTop);\n    } else {\n      if (this.state.height > winHeight - this.state.top) {\n        // In this case, Sticky is higher then viewport minus top offset\n        switch (this.state.status) {\n          case STATUS_ORIGINAL:\n            this.release(this.state.y);\n            this.stickyTop = this.state.y;\n            this.stickyBottom = this.stickyTop + this.state.height;\n          // Commentting out \"break\" is on purpose, because there is a chance to transit to FIXED\n          // from ORIGINAL when calling window.scrollTo().\n          // break;\n          /* eslint-disable-next-line no-fallthrough */\n          case STATUS_RELEASED:\n            // If \"top\" and \"bottom\" are inbetween stickyTop and stickyBottom, then Sticky is in\n            // RELEASE status. Otherwise, it changes to FIXED status, and its bottom sticks to\n            // viewport bottom when scrolling down, or its top sticks to viewport top when scrolling up.\n            this.stickyBottom = this.stickyTop + this.state.height;\n            if (delta > 0 && bottom > this.stickyBottom) {\n              this.fix(this.state.bottom - this.state.height);\n            } else if (delta < 0 && top < this.stickyTop) {\n              this.fix(this.state.top);\n            }\n            break;\n          case STATUS_FIXED:\n            var toRelease = true;\n            var pos = this.state.pos;\n            var height = this.state.height;\n            // In regular cases, when Sticky is in FIXED status,\n            // 1. it's top will stick to the screen top,\n            // 2. it's bottom will stick to the screen bottom,\n            // 3. if not the cases above, then it's height gets changed\n            if (delta > 0 && pos === this.state.top) {\n              // case 1, and scrolling down\n              this.stickyTop = top - delta;\n              this.stickyBottom = this.stickyTop + height;\n            } else if (delta < 0 && pos === this.state.bottom - height) {\n              // case 2, and scrolling up\n              this.stickyBottom = bottom - delta;\n              this.stickyTop = this.stickyBottom - height;\n            } else if (pos !== this.state.bottom - height && pos !== this.state.top) {\n              // case 3\n              // This case only happens when Sticky's bottom sticks to the screen bottom and\n              // its height gets changed. Sticky should be in RELEASE status and update its\n              // sticky bottom by calculating how much height it changed.\n              const deltaHeight = pos + height - this.state.bottom;\n              this.stickyBottom = bottom - delta + deltaHeight;\n              this.stickyTop = this.stickyBottom - height;\n            } else {\n              toRelease = false;\n            }\n            if (toRelease) {\n              this.release(this.stickyTop);\n            }\n            break;\n        }\n      } else {\n        // In this case, Sticky is shorter then viewport minus top offset\n        // and will always fix to the top offset of viewport\n        this.fix(this.state.top);\n      }\n    }\n    this.delta = delta;\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.status !== this.state.status && this.props.onStateChange) {\n      this.props.onStateChange({\n        status: this.state.status\n      });\n    }\n\n    // check if we are up-to-date, is triggered in case of scroll restoration\n    if (this.state.top !== prevState.top) {\n      this.updateInitialDimension();\n      this.update();\n    }\n    const arePropsChanged = !shallowEqual(this.props, prevProps);\n    if (arePropsChanged) {\n      // if the props for enabling are toggled, then trigger the update or reset depending on the current props\n      if (prevProps.enabled !== this.props.enabled) {\n        if (this.props.enabled) {\n          this.setState({\n            activated: true\n          }, () => {\n            this.updateInitialDimension();\n            this.update();\n          });\n        } else {\n          this.setState({\n            activated: false\n          }, () => {\n            this.reset();\n          });\n        }\n      }\n      // if the top or bottomBoundary props were changed, then trigger the update\n      else if (prevProps.top !== this.props.top || prevProps.bottomBoundary !== this.props.bottomBoundary) {\n        this.updateInitialDimension();\n        this.update();\n      }\n    }\n  }\n  componentWillUnmount() {\n    const subscribers = this.subscribers || [];\n    for (var i = subscribers.length - 1; i >= 0; i--) {\n      this.subscribers[i].unsubscribe();\n    }\n  }\n  componentDidMount() {\n    // Only initialize the globals if this is the first\n    // time this component type has been mounted\n    if (!win) {\n      win = window;\n      doc = document;\n      docEl = doc.documentElement;\n      docBody = doc.body;\n      winHeight = win.innerHeight || docEl.clientHeight;\n      M = window.Modernizr;\n      // No Sticky on lower-end browser when no Modernizr\n      if (M && M.prefixed) {\n        canEnableTransforms = M.csstransforms3d;\n        TRANSFORM_PROP = M.prefixed('transform');\n      }\n    }\n\n    // when mount, the scrollTop is not necessary on the top\n    this.scrollTop = docBody.scrollTop + docEl.scrollTop;\n    if (this.props.enabled) {\n      this.setState({\n        activated: true\n      });\n      this.updateInitialDimension();\n      this.update();\n    }\n    // bind the listeners regardless if initially enabled - allows the component to toggle sticky functionality\n    this.subscribers = [subscribe('scrollStart', this.handleScrollStart.bind(this), {\n      useRAF: true\n    }), subscribe('scroll', this.handleScroll.bind(this), {\n      useRAF: true,\n      enableScrollInfo: true\n    }), subscribe('resize', this.handleResize.bind(this), {\n      enableResizeInfo: true\n    })];\n  }\n  translate(style, pos) {\n    const enableTransforms = canEnableTransforms && this.props.enableTransforms;\n    if (enableTransforms && this.state.activated) {\n      style[TRANSFORM_PROP] = 'translate3d(0,' + Math.round(pos) + 'px,0)';\n    } else {\n      style.top = pos + 'px';\n    }\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    return !this.props.shouldFreeze() && !(shallowEqual(this.props, nextProps) && shallowEqual(this.state, nextState));\n  }\n  render() {\n    // TODO, \"overflow: auto\" prevents collapse, need a good way to get children height\n    const innerStyle = {\n      position: this.state.status === STATUS_FIXED ? 'fixed' : 'relative',\n      top: this.state.status === STATUS_FIXED ? '0px' : '',\n      zIndex: this.props.innerZ\n    };\n    const outerStyle = {};\n\n    // always use translate3d to enhance the performance\n    this.translate(innerStyle, this.state.pos);\n    if (this.state.status !== STATUS_ORIGINAL) {\n      innerStyle.width = this.state.width + 'px';\n      outerStyle.height = this.state.height + 'px';\n    }\n    const outerClasses = classNames('sticky-outer-wrapper', this.props.className, {\n      [this.props.activeClass]: this.state.status === STATUS_FIXED,\n      [this.props.releasedClass]: this.state.status === STATUS_RELEASED\n    });\n    const innerClasses = classNames('sticky-inner-wrapper', this.props.innerClass, {\n      [this.props.innerActiveClass]: this.state.status === STATUS_FIXED\n    });\n    const children = this.props.children;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      ref: outer => {\n        this.outerElement = outer;\n      },\n      className: outerClasses,\n      style: outerStyle\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      ref: inner => {\n        this.innerElement = inner;\n      },\n      className: innerClasses,\n      style: innerStyle\n    }, typeof children === 'function' ? children({\n      status: this.state.status\n    }) : children));\n  }\n}\nSticky.displayName = 'Sticky';\nSticky.defaultProps = {\n  shouldFreeze: function () {\n    return false;\n  },\n  enabled: true,\n  top: 0,\n  bottomBoundary: 0,\n  enableTransforms: true,\n  activeClass: 'active',\n  releasedClass: 'released',\n  onStateChange: null,\n  innerClass: '',\n  innerActiveClass: ''\n};\n\n/**\n * @param {Bool} enabled A switch to enable or disable Sticky.\n * @param {String/Number} top A top offset px for Sticky. Could be a selector representing a node\n *        whose height should serve as the top offset.\n * @param {String/Number} bottomBoundary A bottom boundary px on document where Sticky will stop.\n *        Could be a selector representing a node whose bottom should serve as the bottom boudary.\n */\nSticky.propTypes = {\n  children: PropTypes.elementType,\n  enabled: PropTypes.bool,\n  top: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  bottomBoundary: PropTypes.oneOfType([PropTypes.object,\n  // TODO, may remove\n  PropTypes.string, PropTypes.number]),\n  enableTransforms: PropTypes.bool,\n  activeClass: PropTypes.string,\n  releasedClass: PropTypes.string,\n  innerClass: PropTypes.string,\n  innerActiveClass: PropTypes.string,\n  className: PropTypes.string,\n  onStateChange: PropTypes.func,\n  shouldFreeze: PropTypes.func,\n  innerZ: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n};\nSticky.STATUS_ORIGINAL = STATUS_ORIGINAL;\nSticky.STATUS_RELEASED = STATUS_RELEASED;\nSticky.STATUS_FIXED = STATUS_FIXED;\nexport default Sticky;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}